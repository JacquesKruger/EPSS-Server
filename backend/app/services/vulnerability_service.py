"""
Vulnerability Service - Core business logic for vulnerability management
"""

from typing import Dict, List, Optional, Tuple
from datetime import datetime
import structlog
from sqlalchemy.orm import Session
from app.models.vulnerability import Vulnerability, VulnerabilityFinding, Scan, Asset
from app.services.epss_service import epss_service
from app.core.database import get_db

logger = structlog.get_logger()


class VulnerabilityService:
    """Service for managing vulnerability data and calculations"""
    
    def __init__(self):
        self.epss_service = epss_service
    
    async def store_scan_data(self, scan_id: int, processed_data: Dict) -> None:
        """
        Store processed scan data in database
        
        Args:
            scan_id: ID of the scan record
            processed_data: Processed CSV data
        """
        db = next(get_db())
        try:
            # Update scan record
            scan = db.query(Scan).filter(Scan.id == scan_id).first()
            if not scan:
                raise ValueError(f"Scan {scan_id} not found")
            
            # Get unique CVEs and fetch EPSS scores
            unique_cves = processed_data['unique_cves']
            epss_data = await self.epss_service.get_epss_scores(unique_cves)
            
            # Store vulnerabilities
            vulnerability_map = {}
            for cve_id in unique_cves:
                vuln = await self._create_or_update_vulnerability(
                    db, cve_id, epss_data.get(cve_id, {})
                )
                vulnerability_map[cve_id] = vuln
            
            # Store findings
            findings_count = 0
            for finding_data in processed_data['findings']:
                await self._create_finding(
                    db, scan_id, vulnerability_map, finding_data
                )
                findings_count += 1
            
            # Update scan statistics
            scan.total_findings = findings_count
            scan.unique_cves = len(unique_cves)
            scan.status = "completed"
            scan.completed_at = datetime.now()
            
            # Calculate severity counts
            severity_counts = await self._calculate_severity_counts(db, scan_id)
            scan.high_severity_count = severity_counts.get('high', 0)
            scan.medium_severity_count = severity_counts.get('medium', 0)
            scan.low_severity_count = severity_counts.get('low', 0)
            
            db.commit()
            
            logger.info(
                "Scan data stored successfully",
                scan_id=scan_id,
                total_findings=findings_count,
                unique_cves=len(unique_cves)
            )
            
        except Exception as e:
            db.rollback()
            logger.error("Failed to store scan data", scan_id=scan_id, error=str(e))
            raise
        finally:
            db.close()
    
    async def _create_or_update_vulnerability(
        self, 
        db: Session, 
        cve_id: str, 
        epss_data: Dict
    ) -> Vulnerability:
        """
        Create or update vulnerability record
        
        Args:
            db: Database session
            cve_id: CVE identifier
            epss_data: EPSS data for the CVE
            
        Returns:
            Vulnerability record
        """
        # Check if vulnerability already exists
        vuln = db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()
        
        if not vuln:
            # Create new vulnerability
            vuln = Vulnerability(cve_id=cve_id)
            db.add(vuln)
        
        # Update EPSS data
        if epss_data:
            vuln.epss_score = epss_data.get('epss_score')
            vuln.epss_percentile = epss_data.get('percentile')
            vuln.last_epss_update = datetime.now()
        
        # Calculate CPR score if we have both CVSS and EPSS
        if vuln.cvss_score and vuln.epss_score is not None:
            cpr_score, risk_level = await self.epss_service.calculate_cpr_score(
                vuln.cvss_score, vuln.epss_score
            )
            vuln.cpr_score = cpr_score
            vuln.cpr_risk_level = risk_level
        
        db.flush()
        return vuln
    
    async def _create_finding(
        self, 
        db: Session, 
        scan_id: int, 
        vulnerability_map: Dict, 
        finding_data: Dict
    ) -> VulnerabilityFinding:
        """
        Create vulnerability finding record
        
        Args:
            db: Database session
            scan_id: ID of the scan
            vulnerability_map: Map of CVE IDs to vulnerability records
            finding_data: Finding data from CSV
            
        Returns:
            VulnerabilityFinding record
        """
        cve_id = finding_data['cve_id']
        vulnerability = vulnerability_map.get(cve_id)
        
        if not vulnerability:
            logger.warning("Vulnerability not found for CVE", cve_id=cve_id)
            return None
        
        # Create finding
        finding = VulnerabilityFinding(
            vulnerability_id=vulnerability.id,
            scan_id=scan_id,
            ip_address=finding_data['ip_address'],
            hostname=finding_data.get('hostname'),
            port=finding_data.get('port'),
            protocol=finding_data.get('protocol'),
            service=finding_data.get('service'),
            severity=finding_data.get('severity')
        )
        
        db.add(finding)
        db.flush()
        
        # Update or create asset record
        await self._update_asset_record(db, finding_data)
        
        return finding
    
    async def _update_asset_record(self, db: Session, finding_data: Dict) -> None:
        """
        Update asset record with vulnerability information
        
        Args:
            db: Database session
            finding_data: Finding data
        """
        ip_address = finding_data['ip_address']
        
        # Find or create asset
        asset = db.query(Asset).filter(Asset.ip_address == ip_address).first()
        
        if not asset:
            asset = Asset(
                ip_address=ip_address,
                hostname=finding_data.get('hostname')
            )
            db.add(asset)
        
        # Update asset information
        if finding_data.get('hostname') and not asset.hostname:
            asset.hostname = finding_data['hostname']
        
        asset.last_scan = datetime.now()
        db.flush()
    
    async def _calculate_severity_counts(self, db: Session, scan_id: int) -> Dict:
        """
        Calculate severity counts for a scan
        
        Args:
            db: Database session
            scan_id: ID of the scan
            
        Returns:
            Dictionary with severity counts
        """
        findings = db.query(VulnerabilityFinding).filter(
            VulnerabilityFinding.scan_id == scan_id
        ).all()
        
        counts = {'high': 0, 'medium': 0, 'low': 0}
        
        for finding in findings:
            if finding.vulnerability and finding.vulnerability.cvss_score:
                if finding.vulnerability.cvss_score >= 7.0:
                    counts['high'] += 1
                elif finding.vulnerability.cvss_score >= 4.0:
                    counts['medium'] += 1
                else:
                    counts['low'] += 1
        
        return counts
    
    async def get_vulnerabilities_with_cpr_scores(
        self, 
        skip: int = 0, 
        limit: int = 100,
        risk_level: Optional[str] = None,
        min_cpr_score: Optional[float] = None
    ) -> Dict:
        """
        Get vulnerabilities with CPR scores
        
        Args:
            skip: Number of records to skip
            limit: Maximum number of records to return
            risk_level: Filter by risk level
            min_cpr_score: Minimum CPR score filter
            
        Returns:
            Dictionary with vulnerabilities and metadata
        """
        db = next(get_db())
        try:
            query = db.query(Vulnerability).filter(
                Vulnerability.cpr_score.isnot(None)
            )
            
            if risk_level:
                query = query.filter(Vulnerability.cpr_risk_level == risk_level)
            
            if min_cpr_score:
                query = query.filter(Vulnerability.cpr_score >= min_cpr_score)
            
            total = query.count()
            vulnerabilities = query.offset(skip).limit(limit).all()
            
            return {
                "vulnerabilities": [
                    {
                        "cve_id": vuln.cve_id,
                        "title": vuln.title,
                        "description": vuln.description,
                        "cvss_score": vuln.cvss_score,
                        "cvss_severity": vuln.cvss_severity,
                        "epss_score": vuln.epss_score,
                        "epss_percentile": vuln.epss_percentile,
                        "cpr_score": vuln.cpr_score,
                        "cpr_risk_level": vuln.cpr_risk_level,
                        "created_at": vuln.created_at,
                        "updated_at": vuln.updated_at
                    }
                    for vuln in vulnerabilities
                ],
                "total": total,
                "skip": skip,
                "limit": limit
            }
            
        finally:
            db.close()
    
    async def get_asset_risk_analysis(self) -> Dict:
        """
        Get asset risk analysis
        
        Returns:
            Dictionary with asset risk data
        """
        db = next(get_db())
        try:
            # Get assets with vulnerability counts
            assets = db.query(Asset).all()
            
            risk_analysis = {
                "total_assets": len(assets),
                "assets_by_risk": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0
                },
                "top_risky_assets": [],
                "vulnerability_distribution": {
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0
                }
            }
            
            for asset in assets:
                # Calculate asset risk score
                asset_risk = await self._calculate_asset_risk_score(db, asset)
                
                if asset_risk >= 90:
                    risk_analysis["assets_by_risk"]["critical"] += 1
                elif asset_risk >= 70:
                    risk_analysis["assets_by_risk"]["high"] += 1
                elif asset_risk >= 40:
                    risk_analysis["assets_by_risk"]["medium"] += 1
                else:
                    risk_analysis["assets_by_risk"]["low"] += 1
                
                # Add to top risky assets if high risk
                if asset_risk >= 70:
                    risk_analysis["top_risky_assets"].append({
                        "ip_address": asset.ip_address,
                        "hostname": asset.hostname,
                        "risk_score": asset_risk,
                        "total_vulnerabilities": asset.total_vulnerabilities,
                        "critical_vulnerabilities": asset.critical_vulnerabilities
                    })
            
            # Sort top risky assets by risk score
            risk_analysis["top_risky_assets"].sort(
                key=lambda x: x["risk_score"], 
                reverse=True
            )
            risk_analysis["top_risky_assets"] = risk_analysis["top_risky_assets"][:10]
            
            return risk_analysis
            
        finally:
            db.close()
    
    async def _calculate_asset_risk_score(self, db: Session, asset: Asset) -> float:
        """
        Calculate risk score for an asset
        
        Args:
            db: Database session
            asset: Asset record
            
        Returns:
            Risk score (0-100)
        """
        # Get vulnerabilities for this asset
        findings = db.query(VulnerabilityFinding).join(Vulnerability).filter(
            VulnerabilityFinding.ip_address == asset.ip_address
        ).all()
        
        if not findings:
            return 0.0
        
        # Calculate weighted risk score
        total_score = 0.0
        total_weight = 0.0
        
        for finding in findings:
            if finding.vulnerability and finding.vulnerability.cpr_score:
                # Weight by severity
                weight = 1.0
                if finding.vulnerability.cvss_score:
                    if finding.vulnerability.cvss_score >= 9.0:
                        weight = 4.0  # Critical
                    elif finding.vulnerability.cvss_score >= 7.0:
                        weight = 3.0  # High
                    elif finding.vulnerability.cvss_score >= 4.0:
                        weight = 2.0  # Medium
                    else:
                        weight = 1.0  # Low
                
                total_score += finding.vulnerability.cpr_score * weight
                total_weight += weight
        
        return total_score / total_weight if total_weight > 0 else 0.0


# Global service instance
vulnerability_service = VulnerabilityService()
